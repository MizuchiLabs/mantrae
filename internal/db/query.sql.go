// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const createConfig = `-- name: CreateConfig :one
INSERT INTO
  config (profile_id, entrypoints)
VALUES
  (?, ?) RETURNING profile_id, entrypoints
`

type CreateConfigParams struct {
	ProfileID   int64       `json:"profileId"`
	Entrypoints interface{} `json:"entrypoints"`
}

func (q *Queries) CreateConfig(ctx context.Context, arg CreateConfigParams) (Config, error) {
	row := q.queryRow(ctx, q.createConfigStmt, createConfig, arg.ProfileID, arg.Entrypoints)
	var i Config
	err := row.Scan(&i.ProfileID, &i.Entrypoints)
	return i, err
}

const createProfile = `-- name: CreateProfile :one
INSERT INTO
  profiles (name, url, username, password, tls)
VALUES
  (?, ?, ?, ?, ?) RETURNING id, name, url, username, password, tls
`

type CreateProfileParams struct {
	Name     string  `json:"name"`
	Url      string  `json:"url"`
	Username *string `json:"username"`
	Password *string `json:"password"`
	Tls      bool    `json:"tls"`
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (Profile, error) {
	row := q.queryRow(ctx, q.createProfileStmt, createProfile,
		arg.Name,
		arg.Url,
		arg.Username,
		arg.Password,
		arg.Tls,
	)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Username,
		&i.Password,
		&i.Tls,
	)
	return i, err
}

const createProvider = `-- name: CreateProvider :one
INSERT INTO
  providers (
    name,
    type,
    external_ip,
    api_key,
    api_url,
    zone_type,
    proxied,
    is_active
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, name, type, external_ip, api_key, api_url, zone_type, proxied, is_active
`

type CreateProviderParams struct {
	Name       string  `json:"name"`
	Type       string  `json:"type"`
	ExternalIp string  `json:"externalIp"`
	ApiKey     string  `json:"apiKey"`
	ApiUrl     *string `json:"apiUrl"`
	ZoneType   *string `json:"zoneType"`
	Proxied    bool    `json:"proxied"`
	IsActive   bool    `json:"isActive"`
}

func (q *Queries) CreateProvider(ctx context.Context, arg CreateProviderParams) (Provider, error) {
	row := q.queryRow(ctx, q.createProviderStmt, createProvider,
		arg.Name,
		arg.Type,
		arg.ExternalIp,
		arg.ApiKey,
		arg.ApiUrl,
		arg.ZoneType,
		arg.Proxied,
		arg.IsActive,
	)
	var i Provider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ExternalIp,
		&i.ApiKey,
		&i.ApiUrl,
		&i.ZoneType,
		&i.Proxied,
		&i.IsActive,
	)
	return i, err
}

const createSetting = `-- name: CreateSetting :one
INSERT INTO
  settings (key, value)
VALUES
  (?, ?) RETURNING id, "key", value
`

type CreateSettingParams struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) CreateSetting(ctx context.Context, arg CreateSettingParams) (Setting, error) {
	row := q.queryRow(ctx, q.createSettingStmt, createSetting, arg.Key, arg.Value)
	var i Setting
	err := row.Scan(&i.ID, &i.Key, &i.Value)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
  users (username, password, email, type)
VALUES
  (?, ?, ?, ?) RETURNING id, username, password, email, type
`

type CreateUserParams struct {
	Username string  `json:"username"`
	Password string  `json:"password"`
	Email    *string `json:"email"`
	Type     string  `json:"type"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.queryRow(ctx, q.createUserStmt, createUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Type,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Type,
	)
	return i, err
}

const deleteAgentByHostname = `-- name: DeleteAgentByHostname :exec
DELETE FROM agents
WHERE
  hostname = ?
`

func (q *Queries) DeleteAgentByHostname(ctx context.Context, hostname string) error {
	_, err := q.exec(ctx, q.deleteAgentByHostnameStmt, deleteAgentByHostname, hostname)
	return err
}

const deleteAgentByID = `-- name: DeleteAgentByID :exec
DELETE FROM agents
WHERE
  id = ?
`

func (q *Queries) DeleteAgentByID(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteAgentByIDStmt, deleteAgentByID, id)
	return err
}

const deleteConfigByProfileID = `-- name: DeleteConfigByProfileID :exec
DELETE FROM config
WHERE
  profile_id = ?
`

func (q *Queries) DeleteConfigByProfileID(ctx context.Context, profileID int64) error {
	_, err := q.exec(ctx, q.deleteConfigByProfileIDStmt, deleteConfigByProfileID, profileID)
	return err
}

const deleteConfigByProfileName = `-- name: DeleteConfigByProfileName :exec
DELETE FROM config
WHERE
  profile_id = (
    SELECT
      id
    FROM
      profiles
    WHERE
      name = ?
  )
`

func (q *Queries) DeleteConfigByProfileName(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteConfigByProfileNameStmt, deleteConfigByProfileName, name)
	return err
}

const deleteEntryPointByName = `-- name: DeleteEntryPointByName :exec
DELETE FROM entrypoints
WHERE
  profile_id = (
    SELECT
      id
    FROM
      profiles
    WHERE
      profiles.name = ?
  )
  AND entrypoints.name = ?
`

type DeleteEntryPointByNameParams struct {
	Name   string `json:"name"`
	Name_2 string `json:"name2"`
}

func (q *Queries) DeleteEntryPointByName(ctx context.Context, arg DeleteEntryPointByNameParams) error {
	_, err := q.exec(ctx, q.deleteEntryPointByNameStmt, deleteEntryPointByName, arg.Name, arg.Name_2)
	return err
}

const deleteMiddlewareByID = `-- name: DeleteMiddlewareByID :exec
DELETE FROM middlewares
WHERE
  id = ?
`

func (q *Queries) DeleteMiddlewareByID(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteMiddlewareByIDStmt, deleteMiddlewareByID, id)
	return err
}

const deleteMiddlewareByName = `-- name: DeleteMiddlewareByName :exec
DELETE FROM middlewares
WHERE
  name = ?
`

func (q *Queries) DeleteMiddlewareByName(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteMiddlewareByNameStmt, deleteMiddlewareByName, name)
	return err
}

const deleteProfileByID = `-- name: DeleteProfileByID :exec
DELETE FROM profiles
WHERE
  id = ?
`

func (q *Queries) DeleteProfileByID(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteProfileByIDStmt, deleteProfileByID, id)
	return err
}

const deleteProfileByName = `-- name: DeleteProfileByName :exec
DELETE FROM profiles
WHERE
  name = ?
`

func (q *Queries) DeleteProfileByName(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteProfileByNameStmt, deleteProfileByName, name)
	return err
}

const deleteProviderByID = `-- name: DeleteProviderByID :exec
DELETE FROM providers
WHERE
  id = ?
`

func (q *Queries) DeleteProviderByID(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteProviderByIDStmt, deleteProviderByID, id)
	return err
}

const deleteProviderByName = `-- name: DeleteProviderByName :exec
DELETE FROM providers
WHERE
  name = ?
`

func (q *Queries) DeleteProviderByName(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteProviderByNameStmt, deleteProviderByName, name)
	return err
}

const deleteRouterByID = `-- name: DeleteRouterByID :exec
DELETE FROM routers
WHERE
  id = ?
`

func (q *Queries) DeleteRouterByID(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteRouterByIDStmt, deleteRouterByID, id)
	return err
}

const deleteRouterByName = `-- name: DeleteRouterByName :exec
DELETE FROM routers
WHERE
  name = ?
`

func (q *Queries) DeleteRouterByName(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteRouterByNameStmt, deleteRouterByName, name)
	return err
}

const deleteServiceByID = `-- name: DeleteServiceByID :exec
DELETE FROM services
WHERE
  id = ?
`

func (q *Queries) DeleteServiceByID(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteServiceByIDStmt, deleteServiceByID, id)
	return err
}

const deleteServiceByName = `-- name: DeleteServiceByName :exec
DELETE FROM services
WHERE
  name = ?
`

func (q *Queries) DeleteServiceByName(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteServiceByNameStmt, deleteServiceByName, name)
	return err
}

const deleteSettingByID = `-- name: DeleteSettingByID :exec
DELETE FROM settings
WHERE
  id = ?
`

func (q *Queries) DeleteSettingByID(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteSettingByIDStmt, deleteSettingByID, id)
	return err
}

const deleteSettingByKey = `-- name: DeleteSettingByKey :exec
DELETE FROM settings
WHERE
  key = ?
`

func (q *Queries) DeleteSettingByKey(ctx context.Context, key string) error {
	_, err := q.exec(ctx, q.deleteSettingByKeyStmt, deleteSettingByKey, key)
	return err
}

const deleteUserByID = `-- name: DeleteUserByID :exec
DELETE FROM users
WHERE
  id = ?
`

func (q *Queries) DeleteUserByID(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteUserByIDStmt, deleteUserByID, id)
	return err
}

const deleteUserByUsername = `-- name: DeleteUserByUsername :exec
DELETE FROM users
WHERE
  username = ?
`

func (q *Queries) DeleteUserByUsername(ctx context.Context, username string) error {
	_, err := q.exec(ctx, q.deleteUserByUsernameStmt, deleteUserByUsername, username)
	return err
}

const getAgentByID = `-- name: GetAgentByID :one
SELECT
  id, profile_id, hostname, public_ip, private_ips, containers, active_ip, deleted, last_seen
FROM
  agents
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetAgentByID(ctx context.Context, id string) (Agent, error) {
	row := q.queryRow(ctx, q.getAgentByIDStmt, getAgentByID, id)
	var i Agent
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Hostname,
		&i.PublicIp,
		&i.PrivateIps,
		&i.Containers,
		&i.ActiveIp,
		&i.Deleted,
		&i.LastSeen,
	)
	return i, err
}

const getAgentByProfileID = `-- name: GetAgentByProfileID :one
SELECT
  id, profile_id, hostname, public_ip, private_ips, containers, active_ip, deleted, last_seen
FROM
  agents
WHERE
  id = ?
  AND profile_id = ?
LIMIT
  1
`

type GetAgentByProfileIDParams struct {
	ID        string `json:"id"`
	ProfileID int64  `json:"profileId"`
}

func (q *Queries) GetAgentByProfileID(ctx context.Context, arg GetAgentByProfileIDParams) (Agent, error) {
	row := q.queryRow(ctx, q.getAgentByProfileIDStmt, getAgentByProfileID, arg.ID, arg.ProfileID)
	var i Agent
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Hostname,
		&i.PublicIp,
		&i.PrivateIps,
		&i.Containers,
		&i.ActiveIp,
		&i.Deleted,
		&i.LastSeen,
	)
	return i, err
}

const getConfigByProfileID = `-- name: GetConfigByProfileID :one
SELECT
  profile_id, entrypoints
FROM
  config
WHERE
  profile_id = ?
LIMIT
  1
`

func (q *Queries) GetConfigByProfileID(ctx context.Context, profileID int64) (Config, error) {
	row := q.queryRow(ctx, q.getConfigByProfileIDStmt, getConfigByProfileID, profileID)
	var i Config
	err := row.Scan(&i.ProfileID, &i.Entrypoints)
	return i, err
}

const getConfigByProfileName = `-- name: GetConfigByProfileName :one
SELECT
  profile_id, entrypoints
FROM
  config
WHERE
  profile_id = (
    SELECT
      id
    FROM
      profiles
    WHERE
      name = ?
  )
LIMIT
  1
`

func (q *Queries) GetConfigByProfileName(ctx context.Context, name string) (Config, error) {
	row := q.queryRow(ctx, q.getConfigByProfileNameStmt, getConfigByProfileName, name)
	var i Config
	err := row.Scan(&i.ProfileID, &i.Entrypoints)
	return i, err
}

const getDefaultProvider = `-- name: GetDefaultProvider :one
SELECT
  id, name, type, external_ip, api_key, api_url, zone_type, proxied, is_active
FROM
  providers
WHERE
  is_active = true
LIMIT
  1
`

func (q *Queries) GetDefaultProvider(ctx context.Context) (Provider, error) {
	row := q.queryRow(ctx, q.getDefaultProviderStmt, getDefaultProvider)
	var i Provider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ExternalIp,
		&i.ApiKey,
		&i.ApiUrl,
		&i.ZoneType,
		&i.Proxied,
		&i.IsActive,
	)
	return i, err
}

const getMiddlewareByID = `-- name: GetMiddlewareByID :one
SELECT
  id, profile_id, name, provider, type, protocol, agent_id, content
FROM
  middlewares
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetMiddlewareByID(ctx context.Context, id string) (Middleware, error) {
	row := q.queryRow(ctx, q.getMiddlewareByIDStmt, getMiddlewareByID, id)
	var i Middleware
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Name,
		&i.Provider,
		&i.Type,
		&i.Protocol,
		&i.AgentID,
		&i.Content,
	)
	return i, err
}

const getMiddlewareByName = `-- name: GetMiddlewareByName :one
SELECT
  id, profile_id, name, provider, type, protocol, agent_id, content
FROM
  middlewares
WHERE
  name LIKE ?
  AND profile_id = ?
LIMIT
  1
`

type GetMiddlewareByNameParams struct {
	Name      string `json:"name"`
	ProfileID int64  `json:"profileId"`
}

func (q *Queries) GetMiddlewareByName(ctx context.Context, arg GetMiddlewareByNameParams) (Middleware, error) {
	row := q.queryRow(ctx, q.getMiddlewareByNameStmt, getMiddlewareByName, arg.Name, arg.ProfileID)
	var i Middleware
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Name,
		&i.Provider,
		&i.Type,
		&i.Protocol,
		&i.AgentID,
		&i.Content,
	)
	return i, err
}

const getProfileByID = `-- name: GetProfileByID :one
SELECT
  id, name, url, username, password, tls
FROM
  profiles
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetProfileByID(ctx context.Context, id int64) (Profile, error) {
	row := q.queryRow(ctx, q.getProfileByIDStmt, getProfileByID, id)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Username,
		&i.Password,
		&i.Tls,
	)
	return i, err
}

const getProfileByName = `-- name: GetProfileByName :one
SELECT
  id, name, url, username, password, tls
FROM
  profiles
WHERE
  name LIKE ?
LIMIT
  1
`

func (q *Queries) GetProfileByName(ctx context.Context, name string) (Profile, error) {
	row := q.queryRow(ctx, q.getProfileByNameStmt, getProfileByName, name)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Username,
		&i.Password,
		&i.Tls,
	)
	return i, err
}

const getProviderByID = `-- name: GetProviderByID :one
SELECT
  id, name, type, external_ip, api_key, api_url, zone_type, proxied, is_active
FROM
  providers
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetProviderByID(ctx context.Context, id int64) (Provider, error) {
	row := q.queryRow(ctx, q.getProviderByIDStmt, getProviderByID, id)
	var i Provider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ExternalIp,
		&i.ApiKey,
		&i.ApiUrl,
		&i.ZoneType,
		&i.Proxied,
		&i.IsActive,
	)
	return i, err
}

const getRouterByID = `-- name: GetRouterByID :one
SELECT
  id, profile_id, name, provider, protocol, status, agent_id, entry_points, middlewares, rule, rule_syntax, service, priority, tls, dns_provider, errors
FROM
  routers
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetRouterByID(ctx context.Context, id string) (Router, error) {
	row := q.queryRow(ctx, q.getRouterByIDStmt, getRouterByID, id)
	var i Router
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Name,
		&i.Provider,
		&i.Protocol,
		&i.Status,
		&i.AgentID,
		&i.EntryPoints,
		&i.Middlewares,
		&i.Rule,
		&i.RuleSyntax,
		&i.Service,
		&i.Priority,
		&i.Tls,
		&i.DnsProvider,
		&i.Errors,
	)
	return i, err
}

const getRouterByName = `-- name: GetRouterByName :one
SELECT
  id, profile_id, name, provider, protocol, status, agent_id, entry_points, middlewares, rule, rule_syntax, service, priority, tls, dns_provider, errors
FROM
  routers
WHERE
  name LIKE ?
  AND profile_id = ?
LIMIT
  1
`

type GetRouterByNameParams struct {
	Name      string `json:"name"`
	ProfileID int64  `json:"profileId"`
}

func (q *Queries) GetRouterByName(ctx context.Context, arg GetRouterByNameParams) (Router, error) {
	row := q.queryRow(ctx, q.getRouterByNameStmt, getRouterByName, arg.Name, arg.ProfileID)
	var i Router
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Name,
		&i.Provider,
		&i.Protocol,
		&i.Status,
		&i.AgentID,
		&i.EntryPoints,
		&i.Middlewares,
		&i.Rule,
		&i.RuleSyntax,
		&i.Service,
		&i.Priority,
		&i.Tls,
		&i.DnsProvider,
		&i.Errors,
	)
	return i, err
}

const getServiceByID = `-- name: GetServiceByID :one
SELECT
  id, profile_id, name, provider, type, protocol, agent_id, status, server_status, load_balancer, weighted, mirroring, failover
FROM
  services
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetServiceByID(ctx context.Context, id string) (Service, error) {
	row := q.queryRow(ctx, q.getServiceByIDStmt, getServiceByID, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Name,
		&i.Provider,
		&i.Type,
		&i.Protocol,
		&i.AgentID,
		&i.Status,
		&i.ServerStatus,
		&i.LoadBalancer,
		&i.Weighted,
		&i.Mirroring,
		&i.Failover,
	)
	return i, err
}

const getServiceByName = `-- name: GetServiceByName :one
SELECT
  id, profile_id, name, provider, type, protocol, agent_id, status, server_status, load_balancer, weighted, mirroring, failover
FROM
  services
WHERE
  name LIKE ?
  AND profile_id = ?
LIMIT
  1
`

type GetServiceByNameParams struct {
	Name      string `json:"name"`
	ProfileID int64  `json:"profileId"`
}

func (q *Queries) GetServiceByName(ctx context.Context, arg GetServiceByNameParams) (Service, error) {
	row := q.queryRow(ctx, q.getServiceByNameStmt, getServiceByName, arg.Name, arg.ProfileID)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Name,
		&i.Provider,
		&i.Type,
		&i.Protocol,
		&i.AgentID,
		&i.Status,
		&i.ServerStatus,
		&i.LoadBalancer,
		&i.Weighted,
		&i.Mirroring,
		&i.Failover,
	)
	return i, err
}

const getSettingByKey = `-- name: GetSettingByKey :one
SELECT
  id, "key", value
FROM
  settings
WHERE
  key = ?
LIMIT
  1
`

func (q *Queries) GetSettingByKey(ctx context.Context, key string) (Setting, error) {
	row := q.queryRow(ctx, q.getSettingByKeyStmt, getSettingByKey, key)
	var i Setting
	err := row.Scan(&i.ID, &i.Key, &i.Value)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
  id, username, password, email, type
FROM
  users
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.queryRow(ctx, q.getUserByIDStmt, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Type,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT
  id, username, password, email, type
FROM
  users
WHERE
  username = ?
LIMIT
  1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.queryRow(ctx, q.getUserByUsernameStmt, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Type,
	)
	return i, err
}

const listAgents = `-- name: ListAgents :many
SELECT
  id, profile_id, hostname, public_ip, private_ips, containers, active_ip, deleted, last_seen
FROM
  agents
`

func (q *Queries) ListAgents(ctx context.Context) ([]Agent, error) {
	rows, err := q.query(ctx, q.listAgentsStmt, listAgents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Agent
	for rows.Next() {
		var i Agent
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Hostname,
			&i.PublicIp,
			&i.PrivateIps,
			&i.Containers,
			&i.ActiveIp,
			&i.Deleted,
			&i.LastSeen,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAgentsByProfileID = `-- name: ListAgentsByProfileID :many
SELECT
  id, profile_id, hostname, public_ip, private_ips, containers, active_ip, deleted, last_seen
FROM
  agents
WHERE
  profile_id = ?
`

func (q *Queries) ListAgentsByProfileID(ctx context.Context, profileID int64) ([]Agent, error) {
	rows, err := q.query(ctx, q.listAgentsByProfileIDStmt, listAgentsByProfileID, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Agent
	for rows.Next() {
		var i Agent
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Hostname,
			&i.PublicIp,
			&i.PrivateIps,
			&i.Containers,
			&i.ActiveIp,
			&i.Deleted,
			&i.LastSeen,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConfigs = `-- name: ListConfigs :many
SELECT
  profile_id, entrypoints
FROM
  config
`

func (q *Queries) ListConfigs(ctx context.Context) ([]Config, error) {
	rows, err := q.query(ctx, q.listConfigsStmt, listConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Config
	for rows.Next() {
		var i Config
		if err := rows.Scan(&i.ProfileID, &i.Entrypoints); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntryPoints = `-- name: ListEntryPoints :many
SELECT
  profile_id, name, address, as_default, http
FROM
  entrypoints
`

func (q *Queries) ListEntryPoints(ctx context.Context) ([]Entrypoint, error) {
	rows, err := q.query(ctx, q.listEntryPointsStmt, listEntryPoints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entrypoint
	for rows.Next() {
		var i Entrypoint
		if err := rows.Scan(
			&i.ProfileID,
			&i.Name,
			&i.Address,
			&i.AsDefault,
			&i.Http,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntryPointsByProfileID = `-- name: ListEntryPointsByProfileID :many
SELECT
  profile_id, name, address, as_default, http
FROM
  entrypoints
WHERE
  profile_id = ?
`

func (q *Queries) ListEntryPointsByProfileID(ctx context.Context, profileID int64) ([]Entrypoint, error) {
	rows, err := q.query(ctx, q.listEntryPointsByProfileIDStmt, listEntryPointsByProfileID, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entrypoint
	for rows.Next() {
		var i Entrypoint
		if err := rows.Scan(
			&i.ProfileID,
			&i.Name,
			&i.Address,
			&i.AsDefault,
			&i.Http,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMiddlewares = `-- name: ListMiddlewares :many
SELECT
  id, profile_id, name, provider, type, protocol, agent_id, content
FROM
  middlewares
`

func (q *Queries) ListMiddlewares(ctx context.Context) ([]Middleware, error) {
	rows, err := q.query(ctx, q.listMiddlewaresStmt, listMiddlewares)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Middleware
	for rows.Next() {
		var i Middleware
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Name,
			&i.Provider,
			&i.Type,
			&i.Protocol,
			&i.AgentID,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMiddlewaresByProfileID = `-- name: ListMiddlewaresByProfileID :many
SELECT
  id, profile_id, name, provider, type, protocol, agent_id, content
FROM
  middlewares
WHERE
  profile_id = ?
`

func (q *Queries) ListMiddlewaresByProfileID(ctx context.Context, profileID int64) ([]Middleware, error) {
	rows, err := q.query(ctx, q.listMiddlewaresByProfileIDStmt, listMiddlewaresByProfileID, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Middleware
	for rows.Next() {
		var i Middleware
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Name,
			&i.Provider,
			&i.Type,
			&i.Protocol,
			&i.AgentID,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMiddlewaresByProvider = `-- name: ListMiddlewaresByProvider :many
SELECT
  id, profile_id, name, provider, type, protocol, agent_id, content
FROM
  middlewares
WHERE
  provider = ?
`

func (q *Queries) ListMiddlewaresByProvider(ctx context.Context, provider string) ([]Middleware, error) {
	rows, err := q.query(ctx, q.listMiddlewaresByProviderStmt, listMiddlewaresByProvider, provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Middleware
	for rows.Next() {
		var i Middleware
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Name,
			&i.Provider,
			&i.Type,
			&i.Protocol,
			&i.AgentID,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfiles = `-- name: ListProfiles :many
SELECT
  id, name, url, username, password, tls
FROM
  profiles
`

func (q *Queries) ListProfiles(ctx context.Context) ([]Profile, error) {
	rows, err := q.query(ctx, q.listProfilesStmt, listProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Profile
	for rows.Next() {
		var i Profile
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Username,
			&i.Password,
			&i.Tls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProviders = `-- name: ListProviders :many
SELECT
  id, name, type, external_ip, api_key, api_url, zone_type, proxied, is_active
FROM
  providers
`

func (q *Queries) ListProviders(ctx context.Context) ([]Provider, error) {
	rows, err := q.query(ctx, q.listProvidersStmt, listProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Provider
	for rows.Next() {
		var i Provider
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ExternalIp,
			&i.ApiKey,
			&i.ApiUrl,
			&i.ZoneType,
			&i.Proxied,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRouters = `-- name: ListRouters :many
SELECT
  id, profile_id, name, provider, protocol, status, agent_id, entry_points, middlewares, rule, rule_syntax, service, priority, tls, dns_provider, errors
FROM
  routers
`

func (q *Queries) ListRouters(ctx context.Context) ([]Router, error) {
	rows, err := q.query(ctx, q.listRoutersStmt, listRouters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Router
	for rows.Next() {
		var i Router
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Name,
			&i.Provider,
			&i.Protocol,
			&i.Status,
			&i.AgentID,
			&i.EntryPoints,
			&i.Middlewares,
			&i.Rule,
			&i.RuleSyntax,
			&i.Service,
			&i.Priority,
			&i.Tls,
			&i.DnsProvider,
			&i.Errors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutersByProfileID = `-- name: ListRoutersByProfileID :many
SELECT
  id, profile_id, name, provider, protocol, status, agent_id, entry_points, middlewares, rule, rule_syntax, service, priority, tls, dns_provider, errors
FROM
  routers
WHERE
  profile_id = ?
`

func (q *Queries) ListRoutersByProfileID(ctx context.Context, profileID int64) ([]Router, error) {
	rows, err := q.query(ctx, q.listRoutersByProfileIDStmt, listRoutersByProfileID, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Router
	for rows.Next() {
		var i Router
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Name,
			&i.Provider,
			&i.Protocol,
			&i.Status,
			&i.AgentID,
			&i.EntryPoints,
			&i.Middlewares,
			&i.Rule,
			&i.RuleSyntax,
			&i.Service,
			&i.Priority,
			&i.Tls,
			&i.DnsProvider,
			&i.Errors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutersByProvider = `-- name: ListRoutersByProvider :many
SELECT
  id, profile_id, name, provider, protocol, status, agent_id, entry_points, middlewares, rule, rule_syntax, service, priority, tls, dns_provider, errors
FROM
  routers
WHERE
  provider = ?
`

func (q *Queries) ListRoutersByProvider(ctx context.Context, provider string) ([]Router, error) {
	rows, err := q.query(ctx, q.listRoutersByProviderStmt, listRoutersByProvider, provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Router
	for rows.Next() {
		var i Router
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Name,
			&i.Provider,
			&i.Protocol,
			&i.Status,
			&i.AgentID,
			&i.EntryPoints,
			&i.Middlewares,
			&i.Rule,
			&i.RuleSyntax,
			&i.Service,
			&i.Priority,
			&i.Tls,
			&i.DnsProvider,
			&i.Errors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServices = `-- name: ListServices :many
SELECT
  id, profile_id, name, provider, type, protocol, agent_id, status, server_status, load_balancer, weighted, mirroring, failover
FROM
  services
`

func (q *Queries) ListServices(ctx context.Context) ([]Service, error) {
	rows, err := q.query(ctx, q.listServicesStmt, listServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Name,
			&i.Provider,
			&i.Type,
			&i.Protocol,
			&i.AgentID,
			&i.Status,
			&i.ServerStatus,
			&i.LoadBalancer,
			&i.Weighted,
			&i.Mirroring,
			&i.Failover,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByProfileID = `-- name: ListServicesByProfileID :many
SELECT
  id, profile_id, name, provider, type, protocol, agent_id, status, server_status, load_balancer, weighted, mirroring, failover
FROM
  services
WHERE
  profile_id = ?
`

func (q *Queries) ListServicesByProfileID(ctx context.Context, profileID int64) ([]Service, error) {
	rows, err := q.query(ctx, q.listServicesByProfileIDStmt, listServicesByProfileID, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Name,
			&i.Provider,
			&i.Type,
			&i.Protocol,
			&i.AgentID,
			&i.Status,
			&i.ServerStatus,
			&i.LoadBalancer,
			&i.Weighted,
			&i.Mirroring,
			&i.Failover,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByProvider = `-- name: ListServicesByProvider :many
SELECT
  id, profile_id, name, provider, type, protocol, agent_id, status, server_status, load_balancer, weighted, mirroring, failover
FROM
  services
WHERE
  provider = ?
`

func (q *Queries) ListServicesByProvider(ctx context.Context, provider string) ([]Service, error) {
	rows, err := q.query(ctx, q.listServicesByProviderStmt, listServicesByProvider, provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Name,
			&i.Provider,
			&i.Type,
			&i.Protocol,
			&i.AgentID,
			&i.Status,
			&i.ServerStatus,
			&i.LoadBalancer,
			&i.Weighted,
			&i.Mirroring,
			&i.Failover,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSettings = `-- name: ListSettings :many
SELECT
  id, "key", value
FROM
  settings
`

func (q *Queries) ListSettings(ctx context.Context) ([]Setting, error) {
	rows, err := q.query(ctx, q.listSettingsStmt, listSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Setting
	for rows.Next() {
		var i Setting
		if err := rows.Scan(&i.ID, &i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT
  id, username, password, email, type
FROM
  users
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.query(ctx, q.listUsersStmt, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Email,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConfig = `-- name: UpdateConfig :one
UPDATE config
SET
  entrypoints = ?
WHERE
  profile_id = ? RETURNING profile_id, entrypoints
`

type UpdateConfigParams struct {
	Entrypoints interface{} `json:"entrypoints"`
	ProfileID   int64       `json:"profileId"`
}

func (q *Queries) UpdateConfig(ctx context.Context, arg UpdateConfigParams) (Config, error) {
	row := q.queryRow(ctx, q.updateConfigStmt, updateConfig, arg.Entrypoints, arg.ProfileID)
	var i Config
	err := row.Scan(&i.ProfileID, &i.Entrypoints)
	return i, err
}

const updateProfile = `-- name: UpdateProfile :one
UPDATE profiles
SET
  name = ?,
  url = ?,
  username = ?,
  password = ?,
  tls = ?
WHERE
  id = ? RETURNING id, name, url, username, password, tls
`

type UpdateProfileParams struct {
	Name     string  `json:"name"`
	Url      string  `json:"url"`
	Username *string `json:"username"`
	Password *string `json:"password"`
	Tls      bool    `json:"tls"`
	ID       int64   `json:"id"`
}

func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) (Profile, error) {
	row := q.queryRow(ctx, q.updateProfileStmt, updateProfile,
		arg.Name,
		arg.Url,
		arg.Username,
		arg.Password,
		arg.Tls,
		arg.ID,
	)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Username,
		&i.Password,
		&i.Tls,
	)
	return i, err
}

const updateProvider = `-- name: UpdateProvider :one
UPDATE providers
SET
  name = ?,
  type = ?,
  external_ip = ?,
  api_key = ?,
  api_url = ?,
  zone_type = ?,
  proxied = ?,
  is_active = ?
WHERE
  id = ? RETURNING id, name, type, external_ip, api_key, api_url, zone_type, proxied, is_active
`

type UpdateProviderParams struct {
	Name       string  `json:"name"`
	Type       string  `json:"type"`
	ExternalIp string  `json:"externalIp"`
	ApiKey     string  `json:"apiKey"`
	ApiUrl     *string `json:"apiUrl"`
	ZoneType   *string `json:"zoneType"`
	Proxied    bool    `json:"proxied"`
	IsActive   bool    `json:"isActive"`
	ID         int64   `json:"id"`
}

func (q *Queries) UpdateProvider(ctx context.Context, arg UpdateProviderParams) (Provider, error) {
	row := q.queryRow(ctx, q.updateProviderStmt, updateProvider,
		arg.Name,
		arg.Type,
		arg.ExternalIp,
		arg.ApiKey,
		arg.ApiUrl,
		arg.ZoneType,
		arg.Proxied,
		arg.IsActive,
		arg.ID,
	)
	var i Provider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ExternalIp,
		&i.ApiKey,
		&i.ApiUrl,
		&i.ZoneType,
		&i.Proxied,
		&i.IsActive,
	)
	return i, err
}

const updateSetting = `-- name: UpdateSetting :one
UPDATE settings
SET
  value = ?
WHERE
  key = ? RETURNING id, "key", value
`

type UpdateSettingParams struct {
	Value string `json:"value"`
	Key   string `json:"key"`
}

func (q *Queries) UpdateSetting(ctx context.Context, arg UpdateSettingParams) (Setting, error) {
	row := q.queryRow(ctx, q.updateSettingStmt, updateSetting, arg.Value, arg.Key)
	var i Setting
	err := row.Scan(&i.ID, &i.Key, &i.Value)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
  username = ?,
  password = ?,
  email = ?,
  type = ?
WHERE
  id = ? RETURNING id, username, password, email, type
`

type UpdateUserParams struct {
	Username string  `json:"username"`
	Password string  `json:"password"`
	Email    *string `json:"email"`
	Type     string  `json:"type"`
	ID       int64   `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.queryRow(ctx, q.updateUserStmt, updateUser,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Type,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Type,
	)
	return i, err
}

const upsertAgent = `-- name: UpsertAgent :one
INSERT INTO
  agents (
    id,
    profile_id,
    hostname,
    public_ip,
    private_ips,
    containers,
    active_ip,
    deleted,
    last_seen
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET
  profile_id = COALESCE(NULLIF(EXCLUDED.profile_id, 0), agents.profile_id),
  hostname = COALESCE(NULLIF(EXCLUDED.hostname, ''), agents.hostname),
  public_ip = COALESCE(NULLIF(EXCLUDED.public_ip, ''), agents.public_ip),
  private_ips = COALESCE(
    NULLIF(EXCLUDED.private_ips, ''),
    agents.private_ips
  ),
  containers = COALESCE(
    NULLIF(EXCLUDED.containers, ''),
    agents.containers
  ),
  active_ip = COALESCE(NULLIF(EXCLUDED.active_ip, ''), agents.active_ip),
  deleted = COALESCE(NULLIF(EXCLUDED.deleted, FALSE), agents.deleted),
  last_seen = COALESCE(NULLIF(EXCLUDED.last_seen, ''), agents.last_seen) RETURNING id, profile_id, hostname, public_ip, private_ips, containers, active_ip, deleted, last_seen
`

type UpsertAgentParams struct {
	ID         string      `json:"id"`
	ProfileID  int64       `json:"profileId"`
	Hostname   string      `json:"hostname"`
	PublicIp   *string     `json:"publicIp"`
	PrivateIps interface{} `json:"privateIps"`
	Containers interface{} `json:"containers"`
	ActiveIp   *string     `json:"activeIp"`
	Deleted    bool        `json:"deleted"`
	LastSeen   *time.Time  `json:"lastSeen"`
}

func (q *Queries) UpsertAgent(ctx context.Context, arg UpsertAgentParams) (Agent, error) {
	row := q.queryRow(ctx, q.upsertAgentStmt, upsertAgent,
		arg.ID,
		arg.ProfileID,
		arg.Hostname,
		arg.PublicIp,
		arg.PrivateIps,
		arg.Containers,
		arg.ActiveIp,
		arg.Deleted,
		arg.LastSeen,
	)
	var i Agent
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Hostname,
		&i.PublicIp,
		&i.PrivateIps,
		&i.Containers,
		&i.ActiveIp,
		&i.Deleted,
		&i.LastSeen,
	)
	return i, err
}

const upsertEntryPoint = `-- name: UpsertEntryPoint :one
INSERT INTO
  entrypoints (profile_id, name, address, as_default, http)
VALUES
  (?, ?, ?, ?, ?) ON CONFLICT (profile_id, name) DO
UPDATE
SET
  address = EXCLUDED.address,
  as_default = EXCLUDED.as_default,
  http = EXCLUDED.http RETURNING profile_id, name, address, as_default, http
`

type UpsertEntryPointParams struct {
	ProfileID int64       `json:"profileId"`
	Name      string      `json:"name"`
	Address   string      `json:"address"`
	AsDefault *bool       `json:"asDefault"`
	Http      interface{} `json:"http"`
}

func (q *Queries) UpsertEntryPoint(ctx context.Context, arg UpsertEntryPointParams) (Entrypoint, error) {
	row := q.queryRow(ctx, q.upsertEntryPointStmt, upsertEntryPoint,
		arg.ProfileID,
		arg.Name,
		arg.Address,
		arg.AsDefault,
		arg.Http,
	)
	var i Entrypoint
	err := row.Scan(
		&i.ProfileID,
		&i.Name,
		&i.Address,
		&i.AsDefault,
		&i.Http,
	)
	return i, err
}

const upsertMiddleware = `-- name: UpsertMiddleware :one
INSERT INTO
  middlewares (
    id,
    profile_id,
    name,
    provider,
    type,
    protocol,
    agent_id,
    content
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (name, profile_id) DO
UPDATE
SET
  provider = COALESCE(
    NULLIF(EXCLUDED.provider, ''),
    middlewares.provider
  ),
  type = COALESCE(NULLIF(EXCLUDED.type, ''), middlewares.type),
  protocol = COALESCE(
    NULLIF(EXCLUDED.protocol, ''),
    middlewares.protocol
  ),
  agent_id = COALESCE(
    NULLIF(EXCLUDED.agent_id, ''),
    middlewares.agent_id
  ),
  content = COALESCE(NULLIF(EXCLUDED.content, ''), middlewares.content) RETURNING id, profile_id, name, provider, type, protocol, agent_id, content
`

type UpsertMiddlewareParams struct {
	ID        string      `json:"id"`
	ProfileID int64       `json:"profileId"`
	Name      string      `json:"name"`
	Provider  string      `json:"provider"`
	Type      string      `json:"type"`
	Protocol  string      `json:"protocol"`
	AgentID   *string     `json:"agentId"`
	Content   interface{} `json:"content"`
}

func (q *Queries) UpsertMiddleware(ctx context.Context, arg UpsertMiddlewareParams) (Middleware, error) {
	row := q.queryRow(ctx, q.upsertMiddlewareStmt, upsertMiddleware,
		arg.ID,
		arg.ProfileID,
		arg.Name,
		arg.Provider,
		arg.Type,
		arg.Protocol,
		arg.AgentID,
		arg.Content,
	)
	var i Middleware
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Name,
		&i.Provider,
		&i.Type,
		&i.Protocol,
		&i.AgentID,
		&i.Content,
	)
	return i, err
}

const upsertProfile = `-- name: UpsertProfile :one
INSERT INTO
  profiles (id, name, url, username, password, tls)
VALUES
  (?, ?, ?, ?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET
  name = EXCLUDED.name,
  url = EXCLUDED.url,
  username = EXCLUDED.username,
  password = EXCLUDED.password,
  tls = EXCLUDED.tls RETURNING id, name, url, username, password, tls
`

type UpsertProfileParams struct {
	ID       int64   `json:"id"`
	Name     string  `json:"name"`
	Url      string  `json:"url"`
	Username *string `json:"username"`
	Password *string `json:"password"`
	Tls      bool    `json:"tls"`
}

func (q *Queries) UpsertProfile(ctx context.Context, arg UpsertProfileParams) (Profile, error) {
	row := q.queryRow(ctx, q.upsertProfileStmt, upsertProfile,
		arg.ID,
		arg.Name,
		arg.Url,
		arg.Username,
		arg.Password,
		arg.Tls,
	)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Username,
		&i.Password,
		&i.Tls,
	)
	return i, err
}

const upsertProvider = `-- name: UpsertProvider :one
INSERT INTO
  providers (
    id,
    name,
    type,
    external_ip,
    api_key,
    api_url,
    zone_type,
    proxied,
    is_active
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET
  name = EXCLUDED.name,
  type = EXCLUDED.type,
  external_ip = EXCLUDED.external_ip,
  api_key = EXCLUDED.api_key,
  api_url = EXCLUDED.api_url,
  zone_type = EXCLUDED.zone_type,
  proxied = EXCLUDED.proxied,
  is_active = EXCLUDED.is_active RETURNING id, name, type, external_ip, api_key, api_url, zone_type, proxied, is_active
`

type UpsertProviderParams struct {
	ID         int64   `json:"id"`
	Name       string  `json:"name"`
	Type       string  `json:"type"`
	ExternalIp string  `json:"externalIp"`
	ApiKey     string  `json:"apiKey"`
	ApiUrl     *string `json:"apiUrl"`
	ZoneType   *string `json:"zoneType"`
	Proxied    bool    `json:"proxied"`
	IsActive   bool    `json:"isActive"`
}

func (q *Queries) UpsertProvider(ctx context.Context, arg UpsertProviderParams) (Provider, error) {
	row := q.queryRow(ctx, q.upsertProviderStmt, upsertProvider,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.ExternalIp,
		arg.ApiKey,
		arg.ApiUrl,
		arg.ZoneType,
		arg.Proxied,
		arg.IsActive,
	)
	var i Provider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ExternalIp,
		&i.ApiKey,
		&i.ApiUrl,
		&i.ZoneType,
		&i.Proxied,
		&i.IsActive,
	)
	return i, err
}

const upsertRouter = `-- name: UpsertRouter :one
INSERT INTO
  routers (
    id,
    profile_id,
    name,
    provider,
    protocol,
    status,
    agent_id,
    entry_points,
    middlewares,
    rule,
    rule_syntax,
    service,
    priority,
    tls,
    dns_provider,
    errors
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (name, profile_id) DO
UPDATE
SET
  provider = COALESCE(NULLIF(EXCLUDED.provider, ''), routers.provider),
  protocol = COALESCE(NULLIF(EXCLUDED.protocol, ''), routers.protocol),
  status = COALESCE(NULLIF(EXCLUDED.status, ''), routers.status),
  entry_points = COALESCE(
    NULLIF(EXCLUDED.entry_points, ''),
    routers.entry_points
  ),
  middlewares = COALESCE(
    NULLIF(EXCLUDED.middlewares, ''),
    routers.middlewares
  ),
  rule = COALESCE(NULLIF(EXCLUDED.rule, ''), routers.rule),
  rule_syntax = COALESCE(
    NULLIF(EXCLUDED.rule_syntax, ''),
    routers.rule_syntax
  ),
  service = COALESCE(NULLIF(EXCLUDED.service, ''), routers.service),
  priority = COALESCE(NULLIF(EXCLUDED.priority, ''), routers.priority),
  tls = COALESCE(NULLIF(EXCLUDED.tls, ''), routers.tls),
  dns_provider = CASE
    WHEN EXCLUDED.dns_provider = 0 THEN NULL
    WHEN EXCLUDED.dns_provider IS NOT NULL THEN EXCLUDED.dns_provider
    ELSE routers.dns_provider
  END,
  agent_id = COALESCE(NULLIF(EXCLUDED.agent_id, ''), routers.agent_id),
  errors = COALESCE(NULLIF(EXCLUDED.errors, ''), routers.errors) RETURNING id, profile_id, name, provider, protocol, status, agent_id, entry_points, middlewares, rule, rule_syntax, service, priority, tls, dns_provider, errors
`

type UpsertRouterParams struct {
	ID          string      `json:"id"`
	ProfileID   int64       `json:"profileId"`
	Name        string      `json:"name"`
	Provider    string      `json:"provider"`
	Protocol    string      `json:"protocol"`
	Status      *string     `json:"status"`
	AgentID     *string     `json:"agentId"`
	EntryPoints interface{} `json:"entryPoints"`
	Middlewares interface{} `json:"middlewares"`
	Rule        string      `json:"rule"`
	RuleSyntax  *string     `json:"ruleSyntax"`
	Service     string      `json:"service"`
	Priority    *int64      `json:"priority"`
	Tls         interface{} `json:"tls"`
	DnsProvider *int64      `json:"dnsProvider"`
	Errors      interface{} `json:"errors"`
}

func (q *Queries) UpsertRouter(ctx context.Context, arg UpsertRouterParams) (Router, error) {
	row := q.queryRow(ctx, q.upsertRouterStmt, upsertRouter,
		arg.ID,
		arg.ProfileID,
		arg.Name,
		arg.Provider,
		arg.Protocol,
		arg.Status,
		arg.AgentID,
		arg.EntryPoints,
		arg.Middlewares,
		arg.Rule,
		arg.RuleSyntax,
		arg.Service,
		arg.Priority,
		arg.Tls,
		arg.DnsProvider,
		arg.Errors,
	)
	var i Router
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Name,
		&i.Provider,
		&i.Protocol,
		&i.Status,
		&i.AgentID,
		&i.EntryPoints,
		&i.Middlewares,
		&i.Rule,
		&i.RuleSyntax,
		&i.Service,
		&i.Priority,
		&i.Tls,
		&i.DnsProvider,
		&i.Errors,
	)
	return i, err
}

const upsertService = `-- name: UpsertService :one
INSERT INTO
  services (
    id,
    profile_id,
    name,
    provider,
    type,
    protocol,
    agent_id,
    status,
    server_status,
    load_balancer,
    weighted,
    mirroring,
    failover
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (name, profile_id) DO
UPDATE
SET
  provider = COALESCE(NULLIF(EXCLUDED.provider, ''), services.provider),
  type = COALESCE(NULLIF(EXCLUDED.type, ''), services.type),
  protocol = COALESCE(NULLIF(EXCLUDED.protocol, ''), services.protocol),
  status = COALESCE(NULLIF(EXCLUDED.status, ''), services.status),
  server_status = COALESCE(
    NULLIF(EXCLUDED.server_status, ''),
    services.server_status
  ),
  load_balancer = COALESCE(
    NULLIF(EXCLUDED.load_balancer, ''),
    services.load_balancer
  ),
  weighted = COALESCE(NULLIF(EXCLUDED.weighted, ''), services.weighted),
  mirroring = COALESCE(
    NULLIF(EXCLUDED.mirroring, ''),
    services.mirroring
  ),
  failover = COALESCE(NULLIF(EXCLUDED.failover, ''), services.failover),
  agent_id = COALESCE(NULLIF(EXCLUDED.agent_id, ''), services.agent_id) RETURNING id, profile_id, name, provider, type, protocol, agent_id, status, server_status, load_balancer, weighted, mirroring, failover
`

type UpsertServiceParams struct {
	ID           string      `json:"id"`
	ProfileID    int64       `json:"profileId"`
	Name         string      `json:"name"`
	Provider     string      `json:"provider"`
	Type         string      `json:"type"`
	Protocol     string      `json:"protocol"`
	AgentID      *string     `json:"agentId"`
	Status       *string     `json:"status"`
	ServerStatus interface{} `json:"serverStatus"`
	LoadBalancer interface{} `json:"loadBalancer"`
	Weighted     interface{} `json:"weighted"`
	Mirroring    interface{} `json:"mirroring"`
	Failover     interface{} `json:"failover"`
}

func (q *Queries) UpsertService(ctx context.Context, arg UpsertServiceParams) (Service, error) {
	row := q.queryRow(ctx, q.upsertServiceStmt, upsertService,
		arg.ID,
		arg.ProfileID,
		arg.Name,
		arg.Provider,
		arg.Type,
		arg.Protocol,
		arg.AgentID,
		arg.Status,
		arg.ServerStatus,
		arg.LoadBalancer,
		arg.Weighted,
		arg.Mirroring,
		arg.Failover,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Name,
		&i.Provider,
		&i.Type,
		&i.Protocol,
		&i.AgentID,
		&i.Status,
		&i.ServerStatus,
		&i.LoadBalancer,
		&i.Weighted,
		&i.Mirroring,
		&i.Failover,
	)
	return i, err
}

const upsertSetting = `-- name: UpsertSetting :one
INSERT INTO
  settings (id, key, value)
VALUES
  (?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET
  key = EXCLUDED.key,
  value = EXCLUDED.value RETURNING id, "key", value
`

type UpsertSettingParams struct {
	ID    int64  `json:"id"`
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) UpsertSetting(ctx context.Context, arg UpsertSettingParams) (Setting, error) {
	row := q.queryRow(ctx, q.upsertSettingStmt, upsertSetting, arg.ID, arg.Key, arg.Value)
	var i Setting
	err := row.Scan(&i.ID, &i.Key, &i.Value)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO
  users (id, username, password, email, type)
VALUES
  (?, ?, ?, ?, ?) ON CONFLICT (id) DO
UPDATE
SET
  username = EXCLUDED.username,
  password = EXCLUDED.password,
  email = EXCLUDED.email,
  type = EXCLUDED.type RETURNING id, username, password, email, type
`

type UpsertUserParams struct {
	ID       int64   `json:"id"`
	Username string  `json:"username"`
	Password string  `json:"password"`
	Email    *string `json:"email"`
	Type     string  `json:"type"`
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.queryRow(ctx, q.upsertUserStmt, upsertUser,
		arg.ID,
		arg.Username,
		arg.Password,
		arg.Email,
		arg.Type,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Type,
	)
	return i, err
}
