// Code generated by tygo. DO NOT EDIT.

import type { CertAndStores, Options, Store } from '../tls';
import type { Domain } from '../types';

//////////
// source: config.go

/**
 * Message holds configuration information exchanged between parts of traefik.
 */
export interface Message {
	ProviderName: string;
	Configuration?: Configuration;
}
/**
 * Configurations is for currentConfigurations Map.
 */
export type Configurations = { [key: string]: Configuration | undefined };
/**
 * Configuration is the root of the dynamic configuration.
 */
export interface Configuration {
	http?: HTTPConfiguration;
	tcp?: TCPConfiguration;
	udp?: UDPConfiguration;
	tls?: TLSConfiguration;
}
/**
 * TLSConfiguration contains all the configuration parameters of a TLS connection.
 */
export interface TLSConfiguration {
	certificates?: CertAndStores[];
	options?: Options;
	stores?: Store;
}

//////////
// source: http_config.go

/**
 * DefaultHealthCheckInterval is the default value for the ServerHealthCheck interval.
 */
export const DefaultHealthCheckInterval = any;
/**
 * DefaultHealthCheckTimeout is the default value for the ServerHealthCheck timeout.
 */
export const DefaultHealthCheckTimeout = any;
/**
 * DefaultPassHostHeader is the default value for the ServersLoadBalancer passHostHeader.
 */
export const DefaultPassHostHeader = true;
/**
 * DefaultFlushInterval is the default value for the ResponseForwarding flush interval.
 */
export const DefaultFlushInterval = any;
/**
 * MirroringDefaultMirrorBody is the Mirroring.MirrorBody option default value.
 */
export const MirroringDefaultMirrorBody = true;
/**
 * MirroringDefaultMaxBodySize is the Mirroring.MaxBodySize option default value.
 */
export const MirroringDefaultMaxBodySize: number /* int64 */ = -1;
/**
 * HTTPConfiguration contains all the HTTP configuration parameters.
 */
export interface HTTPConfiguration {
	routers?: { [key: string]: Router | undefined };
	services?: { [key: string]: Service | undefined };
	middlewares?: { [key: string]: Middleware | undefined };
	models?: { [key: string]: Model | undefined };
	serversTransports?: { [key: string]: ServersTransport | undefined };
}
/**
 * Model holds model configuration.
 */
export interface Model {
	middlewares?: string[];
	tls?: RouterTLSConfig;
	observability?: RouterObservabilityConfig;
}
/**
 * Service holds a service configuration (can only be of one type at the same time).
 */
export interface Service {
	loadBalancer?: ServersLoadBalancer;
	weighted?: WeightedRoundRobin;
	mirroring?: Mirroring;
	failover?: Failover;
}
/**
 * Router holds the router configuration.
 */
export interface Router {
	entryPoints?: string[];
	middlewares?: string[];
	service?: string;
	rule?: string;
	/**
	 * Deprecated: Please do not use this field and rewrite the router rules to use the v3 syntax.
	 */
	ruleSyntax?: string;
	priority?: number /* int */;
	tls?: RouterTLSConfig;
	observability?: RouterObservabilityConfig;
}
/**
 * RouterTLSConfig holds the TLS configuration for a router.
 */
export interface RouterTLSConfig {
	options?: string;
	certResolver?: string;
	domains?: Domain[];
}
/**
 * RouterObservabilityConfig holds the observability configuration for a router.
 */
export interface RouterObservabilityConfig {
	accessLogs?: boolean;
	tracing?: boolean;
	metrics?: boolean;
}
/**
 * Mirroring holds the Mirroring configuration.
 */
export interface Mirroring {
	service?: string;
	mirrorBody?: boolean;
	maxBodySize?: number /* int64 */;
	mirrors?: MirrorService[];
	healthCheck?: HealthCheck;
}
/**
 * Failover holds the Failover configuration.
 */
export interface Failover {
	service?: string;
	fallback?: string;
	healthCheck?: HealthCheck;
}
/**
 * MirrorService holds the MirrorService configuration.
 */
export interface MirrorService {
	name?: string;
	percent?: number /* int */;
}
/**
 * WeightedRoundRobin is a weighted round robin load-balancer of services.
 */
export interface WeightedRoundRobin {
	services?: WRRService[];
	sticky?: Sticky;
	/**
	 * HealthCheck enables automatic self-healthcheck for this service, i.e.
	 * whenever one of its children is reported as down, this service becomes aware of it,
	 * and takes it into account (i.e. it ignores the down child) when running the
	 * load-balancing algorithm. In addition, if the parent of this service also has
	 * HealthCheck enabled, this service reports to its parent any status change.
	 */
	healthCheck?: HealthCheck;
}
/**
 * WRRService is a reference to a service load-balanced with weighted round-robin.
 */
export interface WRRService {
	name?: string;
	weight?: number /* int */;
}
export interface GRPCStatus {
	code?: any /* codes.Code */;
	msg?: string;
}
/**
 * Sticky holds the sticky configuration.
 */
export interface Sticky {
	/**
	 * Cookie defines the sticky cookie configuration.
	 */
	cookie?: Cookie;
}
/**
 * Cookie holds the sticky configuration based on cookie.
 */
export interface Cookie {
	/**
	 * Name defines the Cookie name.
	 */
	name?: string;
	/**
	 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
	 */
	secure?: boolean;
	/**
	 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
	 */
	httpOnly?: boolean;
	/**
	 * SameSite defines the same site policy.
	 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
	 * +kubebuilder:validation:Enum=none;lax;strict
	 */
	sameSite?: string;
	/**
	 * MaxAge defines the number of seconds until the cookie expires.
	 * When set to a negative number, the cookie expires immediately.
	 * When set to zero, the cookie never expires.
	 */
	maxAge?: number /* int */;
	/**
	 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
	 * When not provided the cookie will be sent on every request to the domain.
	 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
	 */
	path?: string;
	/**
	 * Domain defines the host to which the cookie will be sent.
	 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
	 */
	domain?: string;
}
export type BalancerStrategy = string;
/**
 * BalancerStrategyWRR is the weighted round-robin strategy.
 */
export const BalancerStrategyWRR: BalancerStrategy = 'wrr';
/**
 * BalancerStrategyP2C is the power of two choices strategy.
 */
export const BalancerStrategyP2C: BalancerStrategy = 'p2c';
/**
 * ServersLoadBalancer holds the ServersLoadBalancer configuration.
 */
export interface ServersLoadBalancer {
	sticky?: Sticky;
	servers?: Server[];
	strategy?: BalancerStrategy;
	/**
	 * HealthCheck enables regular active checks of the responsiveness of the
	 * children servers of this load-balancer. To propagate status changes (e.g. all
	 * servers of this service are down) upwards, HealthCheck must also be enabled on
	 * the parent(s) of this service.
	 */
	healthCheck?: ServerHealthCheck;
	passHostHeader?: boolean;
	responseForwarding?: ResponseForwarding;
	serversTransport?: string;
}
/**
 * ResponseForwarding holds the response forwarding configuration.
 */
export interface ResponseForwarding {
	/**
	 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
	 * A negative value means to flush immediately after each write to the client.
	 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
	 * for such responses, writes are flushed to the client immediately.
	 * Default: 100ms
	 */
	flushInterval?: string;
}
/**
 * Server holds the server configuration.
 */
export interface Server {
	url?: string;
	weight?: number /* int */;
	preservePath?: boolean;
}
/**
 * ServerHealthCheck holds the HealthCheck configuration.
 */
export interface ServerHealthCheck {
	scheme?: string;
	mode?: string;
	path?: string;
	method?: string;
	status?: number /* int */;
	port?: number /* int */;
	interval?: string;
	timeout?: string;
	hostname?: string;
	followRedirects?: boolean;
	headers?: { [key: string]: string };
}
/**
 * HealthCheck controls healthcheck awareness and propagation at the services level.
 */
export interface HealthCheck {}
/**
 * ServersTransport options to configure communication between Traefik and the servers.
 */
export interface ServersTransport {
	serverName?: string;
	insecureSkipVerify?: boolean;
	rootCAs?: any /* types.FileOrContent */[];
	certificates?: any /* traefiktls.Certificates */;
	maxIdleConnsPerHost?: number /* int */;
	forwardingTimeouts?: ForwardingTimeouts;
	disableHTTP2?: boolean;
	peerCertURI?: string;
	spiffe?: Spiffe;
}
/**
 * Spiffe holds the SPIFFE configuration.
 */
export interface Spiffe {
	/**
	 * IDs defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain).
	 */
	ids?: string[];
	/**
	 * TrustDomain defines the allowed SPIFFE trust domain.
	 */
	trustDomain?: string;
}
/**
 * ForwardingTimeouts contains timeout configurations for forwarding requests to the backend servers.
 */
export interface ForwardingTimeouts {
	dialTimeout?: string;
	responseHeaderTimeout?: string;
	idleConnTimeout?: string;
	readIdleTimeout?: string;
	pingTimeout?: string;
}

//////////
// source: middlewares.go

/**
 * ForwardAuthDefaultMaxBodySize is the ForwardAuth.MaxBodySize option default value.
 */
export const ForwardAuthDefaultMaxBodySize: number /* int64 */ = -1;
/**
 * Middleware holds the Middleware configuration.
 */
export interface Middleware {
	addPrefix?: AddPrefix;
	stripPrefix?: StripPrefix;
	stripPrefixRegex?: StripPrefixRegex;
	replacePath?: ReplacePath;
	replacePathRegex?: ReplacePathRegex;
	chain?: Chain;
	/**
	 * Deprecated: please use IPAllowList instead.
	 */
	ipWhiteList?: IPWhiteList;
	ipAllowList?: IPAllowList;
	headers?: Headers;
	errors?: ErrorPage;
	rateLimit?: RateLimit;
	redirectRegex?: RedirectRegex;
	redirectScheme?: RedirectScheme;
	basicAuth?: BasicAuth;
	digestAuth?: DigestAuth;
	forwardAuth?: ForwardAuth;
	inFlightReq?: InFlightReq;
	buffering?: Buffering;
	circuitBreaker?: CircuitBreaker;
	compress?: Compress;
	passTLSClientCert?: PassTLSClientCert;
	retry?: Retry;
	contentType?: ContentType;
	grpcWeb?: GrpcWeb;
	plugin?: { [key: string]: PluginConf };
}
/**
 * GrpcWeb holds the gRPC web middleware configuration.
 * This middleware converts a gRPC web request to an HTTP/2 gRPC request.
 */
export interface GrpcWeb {
	/**
	 * AllowOrigins is a list of allowable origins.
	 * Can also be a wildcard origin "*".
	 */
	allowOrigins?: string[];
}
/**
 * ContentType holds the content-type middleware configuration.
 * This middleware exists to enable the correct behavior until at least the default one can be changed in a future version.
 */
export interface ContentType {
	/**
	 * AutoDetect specifies whether to let the `Content-Type` header, if it has not been set by the backend,
	 * be automatically set to a value derived from the contents of the response.
	 * Deprecated: AutoDetect option is deprecated, Content-Type middleware is only meant to be used to enable the content-type detection, please remove any usage of this option.
	 */
	autoDetect?: boolean;
}
/**
 * AddPrefix holds the add prefix middleware configuration.
 * This middleware updates the path of a request before forwarding it.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/addprefix/
 */
export interface AddPrefix {
	/**
	 * Prefix is the string to add before the current path in the requested URL.
	 * It should include a leading slash (/).
	 * +kubebuilder:validation:XValidation:message="must start with a '/'",rule="self.startsWith('/')"
	 */
	prefix?: string;
}
/**
 * BasicAuth holds the basic auth middleware configuration.
 * This middleware restricts access to your services to known users.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/basicauth/
 */
export interface BasicAuth {
	/**
	 * Users is an array of authorized users.
	 * Each user must be declared using the name:hashed-password format.
	 * Tip: Use htpasswd to generate the passwords.
	 */
	users?: Users;
	/**
	 * UsersFile is the path to an external file that contains the authorized users.
	 */
	usersFile?: string;
	/**
	 * Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
	 * Default: traefik.
	 */
	realm?: string;
	/**
	 * RemoveHeader sets the removeHeader option to true to remove the authorization header before forwarding the request to your service.
	 * Default: false.
	 */
	removeHeader?: boolean;
	/**
	 * HeaderField defines a header field to store the authenticated user.
	 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/basicauth/#headerfield
	 */
	headerField?: string;
}
/**
 * Buffering holds the buffering middleware configuration.
 * This middleware retries or limits the size of requests that can be forwarded to backends.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/buffering/#maxrequestbodybytes
 */
export interface Buffering {
	/**
	 * MaxRequestBodyBytes defines the maximum allowed body size for the request (in bytes).
	 * If the request exceeds the allowed size, it is not forwarded to the service, and the client gets a 413 (Request Entity Too Large) response.
	 * Default: 0 (no maximum).
	 */
	maxRequestBodyBytes?: number /* int64 */;
	/**
	 * MemRequestBodyBytes defines the threshold (in bytes) from which the request will be buffered on disk instead of in memory.
	 * Default: 1048576 (1Mi).
	 */
	memRequestBodyBytes?: number /* int64 */;
	/**
	 * MaxResponseBodyBytes defines the maximum allowed response size from the service (in bytes).
	 * If the response exceeds the allowed size, it is not forwarded to the client. The client gets a 500 (Internal Server Error) response instead.
	 * Default: 0 (no maximum).
	 */
	maxResponseBodyBytes?: number /* int64 */;
	/**
	 * MemResponseBodyBytes defines the threshold (in bytes) from which the response will be buffered on disk instead of in memory.
	 * Default: 1048576 (1Mi).
	 */
	memResponseBodyBytes?: number /* int64 */;
	/**
	 * RetryExpression defines the retry conditions.
	 * It is a logical combination of functions with operators AND (&&) and OR (||).
	 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/buffering/#retryexpression
	 */
	retryExpression?: string;
}
/**
 * Chain holds the chain middleware configuration.
 * This middleware enables to define reusable combinations of other pieces of middleware.
 */
export interface Chain {
	/**
	 * Middlewares is the list of middleware names which composes the chain.
	 */
	middlewares?: string[];
}
/**
 * CircuitBreaker holds the circuit breaker middleware configuration.
 * This middleware protects the system from stacking requests to unhealthy services, resulting in cascading failures.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/circuitbreaker/
 */
export interface CircuitBreaker {
	/**
	 * Expression defines the expression that, once matched, opens the circuit breaker and applies the fallback mechanism instead of calling the services.
	 */
	expression?: string;
	/**
	 * CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
	 */
	checkPeriod?: string;
	/**
	 * FallbackDuration is the duration for which the circuit breaker will wait before trying to recover (from a tripped state).
	 */
	fallbackDuration?: string;
	/**
	 * RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
	 */
	recoveryDuration?: string;
	/**
	 * ResponseCode is the status code that the circuit breaker will return while it is in the open state.
	 */
	responseCode?: number /* int */;
}
/**
 * Compress holds the compress middleware configuration.
 * This middleware compresses responses before sending them to the client, using gzip, brotli, or zstd compression.
 */
export interface Compress {
	/**
	 * ExcludedContentTypes defines the list of content types to compare the Content-Type header of the incoming requests and responses before compressing.
	 * `application/grpc` is always excluded.
	 */
	excludedContentTypes?: string[];
	/**
	 * IncludedContentTypes defines the list of content types to compare the Content-Type header of the responses before compressing.
	 */
	includedContentTypes?: string[];
	/**
	 * MinResponseBodyBytes defines the minimum amount of bytes a response body must have to be compressed.
	 * Default: 1024.
	 * +kubebuilder:validation:Minimum=0
	 */
	minResponseBodyBytes?: number /* int */;
	/**
	 * Encodings defines the list of supported compression algorithms.
	 */
	encodings?: string[];
	/**
	 * DefaultEncoding specifies the default encoding if the `Accept-Encoding` header is not in the request or contains a wildcard (`*`).
	 */
	defaultEncoding?: string;
}
/**
 * DigestAuth holds the digest auth middleware configuration.
 * This middleware restricts access to your services to known users.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/digestauth/
 */
export interface DigestAuth {
	/**
	 * Users defines the authorized users.
	 * Each user should be declared using the name:realm:encoded-password format.
	 */
	users?: Users;
	/**
	 * UsersFile is the path to an external file that contains the authorized users for the middleware.
	 */
	usersFile?: string;
	/**
	 * RemoveHeader defines whether to remove the authorization header before forwarding the request to the backend.
	 */
	removeHeader?: boolean;
	/**
	 * Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
	 * Default: traefik.
	 */
	realm?: string;
	/**
	 * HeaderField defines a header field to store the authenticated user.
	 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/basicauth/#headerfield
	 */
	headerField?: string;
}
/**
 * ErrorPage holds the custom error middleware configuration.
 * This middleware returns a custom page in lieu of the default, according to configured ranges of HTTP Status codes.
 */
export interface ErrorPage {
	/**
	 * Status defines which status or range of statuses should result in an error page.
	 * It can be either a status code as a number (500),
	 * as multiple comma-separated numbers (500,502),
	 * as ranges by separating two codes with a dash (500-599),
	 * or a combination of the two (404,418,500-599).
	 */
	status?: string[];
	/**
	 * StatusRewrites defines a mapping of status codes that should be returned instead of the original error status codes.
	 * For example: "418": 404 or "410-418": 404
	 */
	statusRewrites?: { [key: string]: number /* int */ };
	/**
	 * Service defines the name of the service that will serve the error page.
	 */
	service?: string;
	/**
	 * Query defines the URL for the error page (hosted by service).
	 * The {status} variable can be used in order to insert the status code in the URL.
	 * The {originalStatus} variable can be used in order to insert the upstream status code in the URL.
	 * The {url} variable can be used in order to insert the escaped request URL.
	 */
	query?: string;
}
/**
 * ForwardAuth holds the forward auth middleware configuration.
 * This middleware delegates the request authentication to a Service.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/forwardauth/
 */
export interface ForwardAuth {
	/**
	 * Address defines the authentication server address.
	 */
	address?: string;
	/**
	 * TLS defines the configuration used to secure the connection to the authentication server.
	 */
	tls?: ClientTLS;
	/**
	 * TrustForwardHeader defines whether to trust (ie: forward) all X-Forwarded-* headers.
	 */
	trustForwardHeader?: boolean;
	/**
	 * AuthResponseHeaders defines the list of headers to copy from the authentication server response and set on forwarded request, replacing any existing conflicting headers.
	 */
	authResponseHeaders?: string[];
	/**
	 * AuthResponseHeadersRegex defines the regex to match headers to copy from the authentication server response and set on forwarded request, after stripping all headers that match the regex.
	 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/forwardauth/#authresponseheadersregex
	 */
	authResponseHeadersRegex?: string;
	/**
	 * AuthRequestHeaders defines the list of the headers to copy from the request to the authentication server.
	 * If not set or empty then all request headers are passed.
	 */
	authRequestHeaders?: string[];
	/**
	 * AddAuthCookiesToResponse defines the list of cookies to copy from the authentication server response to the response.
	 */
	addAuthCookiesToResponse?: string[];
	/**
	 * HeaderField defines a header field to store the authenticated user.
	 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/forwardauth/#headerfield
	 */
	headerField?: string;
	/**
	 * ForwardBody defines whether to send the request body to the authentication server.
	 */
	forwardBody?: boolean;
	/**
	 * MaxBodySize defines the maximum body size in bytes allowed to be forwarded to the authentication server.
	 */
	maxBodySize?: number /* int64 */;
	/**
	 * PreserveLocationHeader defines whether to forward the Location header to the client as is or prefix it with the domain name of the authentication server.
	 */
	preserveLocationHeader?: boolean;
	/**
	 * PreserveRequestMethod defines whether to preserve the original request method while forwarding the request to the authentication server.
	 */
	preserveRequestMethod?: boolean;
}
/**
 * ClientTLS holds TLS specific configurations as client
 * CA, Cert and Key can be either path or file contents.
 * TODO: remove this struct when CAOptional option will be removed.
 */
export interface ClientTLS {
	ca?: string;
	cert?: string;
	key?: string;
	insecureSkipVerify?: boolean;
	/**
	 * Deprecated: TLS client authentication is a server side option (see https://github.com/golang/go/blob/740a490f71d026bb7d2d13cb8fa2d6d6e0572b70/src/crypto/tls/common.go#L634).
	 */
	caOptional?: boolean;
}
/**
 * Headers holds the headers middleware configuration.
 * This middleware manages the requests and responses headers.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/headers/#customrequestheaders
 */
export interface Headers {
	/**
	 * CustomRequestHeaders defines the header names and values to apply to the request.
	 */
	customRequestHeaders?: { [key: string]: string };
	/**
	 * CustomResponseHeaders defines the header names and values to apply to the response.
	 */
	customResponseHeaders?: { [key: string]: string };
	/**
	 * AccessControlAllowCredentials defines whether the request can include user credentials.
	 */
	accessControlAllowCredentials?: boolean;
	/**
	 * AccessControlAllowHeaders defines the Access-Control-Request-Headers values sent in preflight response.
	 */
	accessControlAllowHeaders?: string[];
	/**
	 * AccessControlAllowMethods defines the Access-Control-Request-Method values sent in preflight response.
	 */
	accessControlAllowMethods?: string[];
	/**
	 * AccessControlAllowOriginList is a list of allowable origins. Can also be a wildcard origin "*".
	 */
	accessControlAllowOriginList?: string[];
	/**
	 * AccessControlAllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
	 */
	accessControlAllowOriginListRegex?: string[];
	/**
	 * AccessControlExposeHeaders defines the Access-Control-Expose-Headers values sent in preflight response.
	 */
	accessControlExposeHeaders?: string[];
	/**
	 * AccessControlMaxAge defines the time that a preflight request may be cached.
	 */
	accessControlMaxAge?: number /* int64 */;
	/**
	 * AddVaryHeader defines whether the Vary header is automatically added/updated when the AccessControlAllowOriginList is set.
	 */
	addVaryHeader?: boolean;
	/**
	 * AllowedHosts defines the fully qualified list of allowed domain names.
	 */
	allowedHosts?: string[];
	/**
	 * HostsProxyHeaders defines the header keys that may hold a proxied hostname value for the request.
	 */
	hostsProxyHeaders?: string[];
	/**
	 * SSLProxyHeaders defines the header keys with associated values that would indicate a valid HTTPS request.
	 * It can be useful when using other proxies (example: "X-Forwarded-Proto": "https").
	 */
	sslProxyHeaders?: { [key: string]: string };
	/**
	 * STSSeconds defines the max-age of the Strict-Transport-Security header.
	 * If set to 0, the header is not set.
	 * +kubebuilder:validation:Minimum=0
	 */
	stsSeconds?: number /* int64 */;
	/**
	 * STSIncludeSubdomains defines whether the includeSubDomains directive is appended to the Strict-Transport-Security header.
	 */
	stsIncludeSubdomains?: boolean;
	/**
	 * STSPreload defines whether the preload flag is appended to the Strict-Transport-Security header.
	 */
	stsPreload?: boolean;
	/**
	 * ForceSTSHeader defines whether to add the STS header even when the connection is HTTP.
	 */
	forceSTSHeader?: boolean;
	/**
	 * FrameDeny defines whether to add the X-Frame-Options header with the DENY value.
	 */
	frameDeny?: boolean;
	/**
	 * CustomFrameOptionsValue defines the X-Frame-Options header value.
	 * This overrides the FrameDeny option.
	 */
	customFrameOptionsValue?: string;
	/**
	 * ContentTypeNosniff defines whether to add the X-Content-Type-Options header with the nosniff value.
	 */
	contentTypeNosniff?: boolean;
	/**
	 * BrowserXSSFilter defines whether to add the X-XSS-Protection header with the value 1; mode=block.
	 */
	browserXssFilter?: boolean;
	/**
	 * CustomBrowserXSSValue defines the X-XSS-Protection header value.
	 * This overrides the BrowserXssFilter option.
	 */
	customBrowserXSSValue?: string;
	/**
	 * ContentSecurityPolicy defines the Content-Security-Policy header value.
	 */
	contentSecurityPolicy?: string;
	/**
	 * ContentSecurityPolicyReportOnly defines the Content-Security-Policy-Report-Only header value.
	 */
	contentSecurityPolicyReportOnly?: string;
	/**
	 * PublicKey is the public key that implements HPKP to prevent MITM attacks with forged certificates.
	 */
	publicKey?: string;
	/**
	 * ReferrerPolicy defines the Referrer-Policy header value.
	 * This allows sites to control whether browsers forward the Referer header to other sites.
	 */
	referrerPolicy?: string;
	/**
	 * PermissionsPolicy defines the Permissions-Policy header value.
	 * This allows sites to control browser features.
	 */
	permissionsPolicy?: string;
	/**
	 * IsDevelopment defines whether to mitigate the unwanted effects of the AllowedHosts, SSL, and STS options when developing.
	 * Usually testing takes place using HTTP, not HTTPS, and on localhost, not your production domain.
	 * If you would like your development environment to mimic production with complete Host blocking, SSL redirects,
	 * and STS headers, leave this as false.
	 */
	isDevelopment?: boolean;
	/**
	 * Deprecated: FeaturePolicy option is deprecated, please use PermissionsPolicy instead.
	 */
	featurePolicy?: string;
	/**
	 * Deprecated: SSLRedirect option is deprecated, please use EntryPoint redirection or RedirectScheme instead.
	 */
	sslRedirect?: boolean;
	/**
	 * Deprecated: SSLTemporaryRedirect option is deprecated, please use EntryPoint redirection or RedirectScheme instead.
	 */
	sslTemporaryRedirect?: boolean;
	/**
	 * Deprecated: SSLHost option is deprecated, please use RedirectRegex instead.
	 */
	sslHost?: string;
	/**
	 * Deprecated: SSLForceHost option is deprecated, please use RedirectRegex instead.
	 */
	sslForceHost?: boolean;
}
/**
 * IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipallowlist/#ipstrategy
 */
export interface IPStrategy {
	/**
	 * Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
	 * +kubebuilder:validation:Minimum=0
	 */
	depth?: number /* int */;
	/**
	 * ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
	 */
	excludedIPs?: string[];
	/**
	 * IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
	 */
	ipv6Subnet?: number /* int */;
}
/**
 * IPWhiteList holds the IP whitelist middleware configuration.
 * This middleware limits allowed requests based on the client IP.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipwhitelist/
 * Deprecated: please use IPAllowList instead.
 */
export interface IPWhiteList {
	/**
	 * SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation). Required.
	 */
	sourceRange?: string[];
	ipStrategy?: IPStrategy;
}
/**
 * IPAllowList holds the IP allowlist middleware configuration.
 * This middleware limits allowed requests based on the client IP.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipallowlist/
 */
export interface IPAllowList {
	/**
	 * SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation).
	 */
	sourceRange?: string[];
	ipStrategy?: IPStrategy;
	/**
	 * RejectStatusCode defines the HTTP status code used for refused requests.
	 * If not set, the default is 403 (Forbidden).
	 */
	rejectStatusCode?: number /* int */;
}
/**
 * InFlightReq holds the in-flight request middleware configuration.
 * This middleware limits the number of requests being processed and served concurrently.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/inflightreq/
 */
export interface InFlightReq {
	/**
	 * Amount defines the maximum amount of allowed simultaneous in-flight request.
	 * The middleware responds with HTTP 429 Too Many Requests if there are already amount requests in progress (based on the same sourceCriterion strategy).
	 * +kubebuilder:validation:Minimum=0
	 */
	amount?: number /* int64 */;
	/**
	 * SourceCriterion defines what criterion is used to group requests as originating from a common source.
	 * If several strategies are defined at the same time, an error will be raised.
	 * If none are set, the default is to use the requestHost.
	 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/inflightreq/#sourcecriterion
	 */
	sourceCriterion?: SourceCriterion;
}
/**
 * PassTLSClientCert holds the pass TLS client cert middleware configuration.
 * This middleware adds the selected data from the passed client TLS certificate to a header.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/passtlsclientcert/
 */
export interface PassTLSClientCert {
	/**
	 * PEM sets the X-Forwarded-Tls-Client-Cert header with the certificate.
	 */
	pem?: boolean;
	/**
	 * Info selects the specific client certificate details you want to add to the X-Forwarded-Tls-Client-Cert-Info header.
	 */
	info?: TLSClientCertificateInfo;
}
/**
 * SourceCriterion defines what criterion is used to group requests as originating from a common source.
 * If none are set, the default is to use the request's remote address field.
 * All fields are mutually exclusive.
 */
export interface SourceCriterion {
	ipStrategy?: IPStrategy;
	/**
	 * RequestHeaderName defines the name of the header used to group incoming requests.
	 */
	requestHeaderName?: string;
	/**
	 * RequestHost defines whether to consider the request Host as the source.
	 */
	requestHost?: boolean;
}
/**
 * RateLimit holds the rate limit configuration.
 * This middleware ensures that services will receive a fair amount of requests, and allows one to define what fair is.
 */
export interface RateLimit {
	/**
	 * Average is the maximum rate, by default in requests/s, allowed for the given source.
	 * It defaults to 0, which means no rate limiting.
	 * The rate is actually defined by dividing Average by Period. So for a rate below 1req/s,
	 * one needs to define a Period larger than a second.
	 */
	average?: number /* int64 */;
	/**
	 * Period, in combination with Average, defines the actual maximum rate, such as:
	 * r = Average / Period. It defaults to a second.
	 */
	period?: string;
	/**
	 * Burst is the maximum number of requests allowed to arrive in the same arbitrarily small period of time.
	 * It defaults to 1.
	 */
	burst?: number /* int64 */;
	/**
	 * SourceCriterion defines what criterion is used to group requests as originating from a common source.
	 * If several strategies are defined at the same time, an error will be raised.
	 * If none are set, the default is to use the request's remote address field (as an ipStrategy).
	 */
	sourceCriterion?: SourceCriterion;
	/**
	 * Redis stores the configuration for using Redis as a bucket in the rate-limiting algorithm.
	 * If not specified, Traefik will default to an in-memory bucket for the algorithm.
	 */
	redis?: Redis;
}
/**
 * Redis holds the Redis configuration.
 */
export interface Redis {
	/**
	 * Endpoints contains either a single address or a seed list of host:port addresses.
	 * Default value is ["localhost:6379"].
	 */
	endpoints?: string[];
	/**
	 * TLS defines TLS-specific configurations, including the CA, certificate, and key,
	 * which can be provided as a file path or file content.
	 */
	tls?: ClientTLS;
	/**
	 * Username defines the username to connect to the Redis server.
	 */
	username?: string;
	/**
	 * Password defines the password to connect to the Redis server.
	 */
	password?: string;
	/**
	 * DB defines the Redis database that will be selected after connecting to the server.
	 */
	db?: number /* int */;
	/**
	 * PoolSize defines the initial number of socket connections.
	 * If the pool runs out of available connections, additional ones will be created beyond PoolSize.
	 * This can be limited using MaxActiveConns.
	 * Default value is 0, meaning 10 connections per every available CPU as reported by runtime.GOMAXPROCS.
	 */
	poolSize?: number /* int */;
	/**
	 * MinIdleConns defines the minimum number of idle connections.
	 * Default value is 0, and idle connections are not closed by default.
	 */
	minIdleConns?: number /* int */;
	/**
	 * MaxActiveConns defines the maximum number of connections allocated by the pool at a given time.
	 * Default value is 0, meaning there is no limit.
	 */
	maxActiveConns?: number /* int */;
	/**
	 * ReadTimeout defines the timeout for socket read operations.
	 * Default value is 3 seconds.
	 */
	readTimeout?: string;
	/**
	 * WriteTimeout defines the timeout for socket write operations.
	 * Default value is 3 seconds.
	 */
	writeTimeout?: string;
	/**
	 * DialTimeout sets the timeout for establishing new connections.
	 * Default value is 5 seconds.
	 */
	dialTimeout?: string;
}
/**
 * RedirectRegex holds the redirect regex middleware configuration.
 * This middleware redirects a request using regex matching and replacement.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/redirectregex/#regex
 */
export interface RedirectRegex {
	/**
	 * Regex defines the regex used to match and capture elements from the request URL.
	 */
	regex?: string;
	/**
	 * Replacement defines how to modify the URL to have the new target URL.
	 */
	replacement?: string;
	/**
	 * Permanent defines whether the redirection is permanent (301).
	 */
	permanent?: boolean;
}
/**
 * RedirectScheme holds the redirect scheme middleware configuration.
 * This middleware redirects requests from a scheme/port to another.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/redirectscheme/
 */
export interface RedirectScheme {
	/**
	 * Scheme defines the scheme of the new URL.
	 */
	scheme?: string;
	/**
	 * Port defines the port of the new URL.
	 */
	port?: string;
	/**
	 * Permanent defines whether the redirection is permanent (301).
	 */
	permanent?: boolean;
}
/**
 * ReplacePath holds the replace path middleware configuration.
 * This middleware replaces the path of the request URL and store the original path in an X-Replaced-Path header.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/replacepath/
 */
export interface ReplacePath {
	/**
	 * Path defines the path to use as replacement in the request URL.
	 */
	path?: string;
}
/**
 * ReplacePathRegex holds the replace path regex middleware configuration.
 * This middleware replaces the path of a URL using regex matching and replacement.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/replacepathregex/
 */
export interface ReplacePathRegex {
	/**
	 * Regex defines the regular expression used to match and capture the path from the request URL.
	 */
	regex?: string;
	/**
	 * Replacement defines the replacement path format, which can include captured variables.
	 */
	replacement?: string;
}
/**
 * Retry holds the retry middleware configuration.
 * This middleware reissues requests a given number of times to a backend server if that server does not reply.
 * As soon as the server answers, the middleware stops retrying, regardless of the response status.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/retry/
 */
export interface Retry {
	/**
	 * Attempts defines how many times the request should be retried.
	 */
	attempts?: number /* int */;
	/**
	 * InitialInterval defines the first wait time in the exponential backoff series.
	 * The maximum interval is calculated as twice the initialInterval.
	 * If unspecified, requests will be retried immediately.
	 * The value of initialInterval should be provided in seconds or as a valid duration format,
	 * see https://pkg.go.dev/time#ParseDuration.
	 */
	initialInterval?: string;
}
/**
 * StripPrefix holds the strip prefix middleware configuration.
 * This middleware removes the specified prefixes from the URL path.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/stripprefix/
 */
export interface StripPrefix {
	/**
	 * Prefixes defines the prefixes to strip from the request URL.
	 */
	prefixes?: string[];
	/**
	 * Deprecated: ForceSlash option is deprecated, please remove any usage of this option.
	 * ForceSlash ensures that the resulting stripped path is not the empty string, by replacing it with / when necessary.
	 * Default: true.
	 */
	forceSlash?: boolean;
}
/**
 * StripPrefixRegex holds the strip prefix regex middleware configuration.
 * This middleware removes the matching prefixes from the URL path.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/stripprefixregex/
 */
export interface StripPrefixRegex {
	/**
	 * Regex defines the regular expression to match the path prefix from the request URL.
	 */
	regex?: string[];
}
/**
 * TLSClientCertificateInfo holds the client TLS certificate info configuration.
 */
export interface TLSClientCertificateInfo {
	/**
	 * NotAfter defines whether to add the Not After information from the Validity part.
	 */
	notAfter?: boolean;
	/**
	 * NotBefore defines whether to add the Not Before information from the Validity part.
	 */
	notBefore?: boolean;
	/**
	 * Sans defines whether to add the Subject Alternative Name information from the Subject Alternative Name part.
	 */
	sans?: boolean;
	/**
	 * SerialNumber defines whether to add the client serialNumber information.
	 */
	serialNumber?: boolean;
	/**
	 * Subject defines the client certificate subject details to add to the X-Forwarded-Tls-Client-Cert-Info header.
	 */
	subject?: TLSClientCertificateSubjectDNInfo;
	/**
	 * Issuer defines the client certificate issuer details to add to the X-Forwarded-Tls-Client-Cert-Info header.
	 */
	issuer?: TLSClientCertificateIssuerDNInfo;
}
/**
 * TLSClientCertificateIssuerDNInfo holds the client TLS certificate distinguished name info configuration.
 * cf https://tools.ietf.org/html/rfc3739
 */
export interface TLSClientCertificateIssuerDNInfo {
	/**
	 * Country defines whether to add the country information into the issuer.
	 */
	country?: boolean;
	/**
	 * Province defines whether to add the province information into the issuer.
	 */
	province?: boolean;
	/**
	 * Locality defines whether to add the locality information into the issuer.
	 */
	locality?: boolean;
	/**
	 * Organization defines whether to add the organization information into the issuer.
	 */
	organization?: boolean;
	/**
	 * CommonName defines whether to add the organizationalUnit information into the issuer.
	 */
	commonName?: boolean;
	/**
	 * SerialNumber defines whether to add the serialNumber information into the issuer.
	 */
	serialNumber?: boolean;
	/**
	 * DomainComponent defines whether to add the domainComponent information into the issuer.
	 */
	domainComponent?: boolean;
}
/**
 * TLSClientCertificateSubjectDNInfo holds the client TLS certificate distinguished name info configuration.
 * cf https://tools.ietf.org/html/rfc3739
 */
export interface TLSClientCertificateSubjectDNInfo {
	/**
	 * Country defines whether to add the country information into the subject.
	 */
	country?: boolean;
	/**
	 * Province defines whether to add the province information into the subject.
	 */
	province?: boolean;
	/**
	 * Locality defines whether to add the locality information into the subject.
	 */
	locality?: boolean;
	/**
	 * Organization defines whether to add the organization information into the subject.
	 */
	organization?: boolean;
	/**
	 * OrganizationalUnit defines whether to add the organizationalUnit information into the subject.
	 */
	organizationalUnit?: boolean;
	/**
	 * CommonName defines whether to add the organizationalUnit information into the subject.
	 */
	commonName?: boolean;
	/**
	 * SerialNumber defines whether to add the serialNumber information into the subject.
	 */
	serialNumber?: boolean;
	/**
	 * DomainComponent defines whether to add the domainComponent information into the subject.
	 */
	domainComponent?: boolean;
}
/**
 * Users holds a list of users.
 */
export type Users = string[];
/**
 * HeaderModifier holds the request/response header modifier configuration.
 */
export interface HeaderModifier {
	set?: { [key: string]: string };
	add?: { [key: string]: string };
	remove?: string[];
}
/**
 * RequestRedirect holds the request redirect middleware configuration.
 */
export interface RequestRedirect {
	scheme?: string;
	hostname?: string;
	port?: string;
	path?: string;
	pathPrefix?: string;
	statusCode?: number /* int */;
}
/**
 * URLRewrite holds the URL rewrite middleware configuration.
 */
export interface URLRewrite {
	hostname?: string;
	path?: string;
	pathPrefix?: string;
}

//////////
// source: plugins.go

/**
 * PluginConf holds the plugin configuration.
 */
export type PluginConf = { [key: string]: any };

//////////
// source: tcp_config.go

/**
 * TCPConfiguration contains all the TCP configuration parameters.
 */
export interface TCPConfiguration {
	routers?: { [key: string]: TCPRouter | undefined };
	services?: { [key: string]: TCPService | undefined };
	middlewares?: { [key: string]: TCPMiddleware | undefined };
	serversTransports?: { [key: string]: TCPServersTransport | undefined };
}
/**
 * TCPModel is a set of default router's values.
 */
export interface TCPModel {}
/**
 * TCPService holds a tcp service configuration (can only be of one type at the same time).
 */
export interface TCPService {
	loadBalancer?: TCPServersLoadBalancer;
	weighted?: TCPWeightedRoundRobin;
}
/**
 * TCPWeightedRoundRobin is a weighted round robin tcp load-balancer of services.
 */
export interface TCPWeightedRoundRobin {
	services?: TCPWRRService[];
}
/**
 * TCPWRRService is a reference to a tcp service load-balanced with weighted round robin.
 */
export interface TCPWRRService {
	name?: string;
	weight?: number /* int */;
}
/**
 * TCPRouter holds the router configuration.
 */
export interface TCPRouter {
	entryPoints?: string[];
	middlewares?: string[];
	service?: string;
	rule?: string;
	/**
	 * Deprecated: Please do not use this field and rewrite the router rules to use the v3 syntax.
	 */
	ruleSyntax?: string;
	priority?: number /* int */;
	tls?: RouterTCPTLSConfig;
}
/**
 * RouterTCPTLSConfig holds the TLS configuration for a router.
 */
export interface RouterTCPTLSConfig {
	passthrough: boolean;
	options?: string;
	certResolver?: string;
	domains?: Domain[];
}
/**
 * TCPServersLoadBalancer holds the LoadBalancerService configuration.
 */
export interface TCPServersLoadBalancer {
	proxyProtocol?: ProxyProtocol;
	servers?: TCPServer[];
	serversTransport?: string;
	/**
	 * TerminationDelay, corresponds to the deadline that the proxy sets, after one
	 * of its connected peers indicates it has closed the writing capability of its
	 * connection, to close the reading capability as well, hence fully terminating the
	 * connection. It is a duration in milliseconds, defaulting to 100. A negative value
	 * means an infinite deadline (i.e. the reading capability is never closed).
	 * Deprecated: use ServersTransport to configure the TerminationDelay instead.
	 */
	terminationDelay?: number /* int */;
}
/**
 * TCPServer holds a TCP Server configuration.
 */
export interface TCPServer {
	address?: string;
	tls?: boolean;
}
/**
 * ProxyProtocol holds the PROXY Protocol configuration.
 * More info: https://doc.traefik.io/traefik/v3.4/routing/services/#proxy-protocol
 */
export interface ProxyProtocol {
	/**
	 * Version defines the PROXY Protocol version to use.
	 * +kubebuilder:validation:Minimum=1
	 * +kubebuilder:validation:Maximum=2
	 */
	version?: number /* int */;
}
/**
 * TCPServersTransport options to configure communication between Traefik and the servers.
 */
export interface TCPServersTransport {
	dialKeepAlive?: string;
	dialTimeout?: string;
	/**
	 * TerminationDelay, corresponds to the deadline that the proxy sets, after one
	 * of its connected peers indicates it has closed the writing capability of its
	 * connection, to close the reading capability as well, hence fully terminating the
	 * connection. It is a duration in milliseconds, defaulting to 100. A negative value
	 * means an infinite deadline (i.e. the reading capability is never closed).
	 */
	terminationDelay?: string;
	tls?: TLSClientConfig;
}
/**
 * TLSClientConfig options to configure TLS communication between Traefik and the servers.
 */
export interface TLSClientConfig {
	serverName?: string;
	insecureSkipVerify?: boolean;
	rootCAs?: any /* types.FileOrContent */[];
	certificates?: any /* traefiktls.Certificates */;
	peerCertURI?: string;
	spiffe?: Spiffe;
}

//////////
// source: tcp_middlewares.go

/**
 * TCPMiddleware holds the TCPMiddleware configuration.
 */
export interface TCPMiddleware {
	inFlightConn?: TCPInFlightConn;
	/**
	 * Deprecated: please use IPAllowList instead.
	 */
	ipWhiteList?: TCPIPWhiteList;
	ipAllowList?: TCPIPAllowList;
}
/**
 * TCPInFlightConn holds the TCP InFlightConn middleware configuration.
 * This middleware prevents services from being overwhelmed with high load,
 * by limiting the number of allowed simultaneous connections for one IP.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/tcp/inflightconn/
 */
export interface TCPInFlightConn {
	/**
	 * Amount defines the maximum amount of allowed simultaneous connections.
	 * The middleware closes the connection if there are already amount connections opened.
	 * +kubebuilder:validation:Minimum=0
	 */
	amount?: number /* int64 */;
}
/**
 * TCPIPWhiteList holds the TCP IPWhiteList middleware configuration.
 * Deprecated: please use IPAllowList instead.
 */
export interface TCPIPWhiteList {
	/**
	 * SourceRange defines the allowed IPs (or ranges of allowed IPs by using CIDR notation).
	 */
	sourceRange?: string[];
}
/**
 * TCPIPAllowList holds the TCP IPAllowList middleware configuration.
 * This middleware limits allowed requests based on the client IP.
 * More info: https://doc.traefik.io/traefik/v3.4/middlewares/tcp/ipallowlist/
 */
export interface TCPIPAllowList {
	/**
	 * SourceRange defines the allowed IPs (or ranges of allowed IPs by using CIDR notation).
	 */
	sourceRange?: string[];
}

//////////
// source: udp_config.go

/**
 * UDPConfiguration contains all the UDP configuration parameters.
 */
export interface UDPConfiguration {
	routers?: { [key: string]: UDPRouter | undefined };
	services?: { [key: string]: UDPService | undefined };
}
/**
 * UDPService defines the configuration for a UDP service. All fields are mutually exclusive.
 */
export interface UDPService {
	loadBalancer?: UDPServersLoadBalancer;
	weighted?: UDPWeightedRoundRobin;
}
/**
 * UDPWeightedRoundRobin is a weighted round robin UDP load-balancer of services.
 */
export interface UDPWeightedRoundRobin {
	services?: UDPWRRService[];
}
/**
 * UDPWRRService is a reference to a UDP service load-balanced with weighted round robin.
 */
export interface UDPWRRService {
	name?: string;
	weight?: number /* int */;
}
/**
 * UDPRouter defines the configuration for an UDP router.
 */
export interface UDPRouter {
	entryPoints?: string[];
	service?: string;
}
/**
 * UDPServersLoadBalancer defines the configuration for a load-balancer of UDP servers.
 */
export interface UDPServersLoadBalancer {
	servers?: UDPServer[];
}
/**
 * UDPServer defines a UDP server configuration.
 */
export interface UDPServer {
	address?: string;
}
